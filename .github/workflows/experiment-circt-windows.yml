name: "[Experimental] CIRCT Windows Toolchain Test"

# Manual-trigger only — this is an experiment to find which Windows toolchain
# can successfully build CIRCT with shared libraries (DLLs).
#
# Matrix tests three toolchains:
#   1. msvc       — cl.exe via Visual Studio, LLVM_BUILD_LLVM_DYLIB=ON
#   2. clang-cl   — Clang in MSVC-compat mode, LLVM_BUILD_LLVM_DYLIB=ON
#   3. mingw      — MSYS2 CLANG64 (Clang + MinGW), LLVM_BUILD_LLVM_DYLIB=ON
#
# fail-fast: false ensures each job runs independently.
# Compare the three to decide which goes into the real build-circt.yml.
#
# Required build deps: Python 3, Ninja, CMake 3.20+, C++ compiler
# Optional deps (Verilator, Vivado, z3, etc.) auto-skip if not found.

on:
  push:
    tags:
      - "circt-exp-v*"
  workflow_dispatch:
    inputs:
      circt_version:
        description: "CIRCT firtool release tag (e.g., 1.140.0)"
        required: true
        type: string

permissions:
  contents: write

env:
  CIRCT_VERSION: ${{ inputs.circt_version || github.ref_name }}

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          # --- Toolchain 1: Plain MSVC (cl.exe) ---
          - toolchain: msvc
            os: windows-latest
            shell: cmd
            parallel_jobs: 4

          # --- Toolchain 2: clang-cl (MSVC ABI) ---
          - toolchain: clang-cl
            os: windows-latest
            shell: cmd
            parallel_jobs: 4

          # --- Toolchain 3: MinGW via MSYS2 CLANG64 ---
          # This is the only one that might produce a shared libLLVM.dll
          - toolchain: mingw
            os: windows-latest
            shell: msys2 {0}
            parallel_jobs: 4

    runs-on: ${{ matrix.os }}
    defaults:
      run:
        shell: ${{ matrix.shell }}

    timeout-minutes: 360

    steps:
      - name: Derive CIRCT version
        id: version
        shell: bash
        run: |
          RAW="${{ env.CIRCT_VERSION }}"
          VERSION=$(echo "$RAW" | sed -E 's/^.*-v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Failed to extract valid version from '$RAW'. Expected X.Y.Z"
            exit 1
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=firtool-${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Testing CIRCT ${VERSION} with toolchain: ${{ matrix.toolchain }}"

      # ========================================
      # COMMON: Free disk space (Windows runners have ~14 GB free)
      # NOTE: Must run BEFORE setup-python — this step deletes C:\hostedtoolcache,
      # which is where setup-python installs Python. If setup-python runs first,
      # the Python install gets wiped and CMake cannot find it.
      # ========================================
      - name: Free disk space
        shell: powershell
        run: |
          # Remove large pre-installed components to free ~10-15 GB
          Remove-Item -Recurse -Force "C:\Program Files\dotnet" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Program Files (x86)\Microsoft SDKs\Azure" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\hostedtoolcache" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Program Files\MongoDB" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Program Files\PostgreSQL" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Program Files\MySQL" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\imagegeneration\installers" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Selenium" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Program Files (x86)\Google" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\Program Files\Google" -ErrorAction SilentlyContinue
          Get-PSDrive C | Select-Object Used, Free

      # ========================================
      # COMMON: Python 3 (required by LLVM/CIRCT tablegen)
      # Must run AFTER Free disk space (see note above).
      # ========================================
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # ========================================
      # TOOLCHAIN SETUP: MSVC
      # ========================================
      - name: "[msvc] Set up MSVC environment"
        if: matrix.toolchain == 'msvc'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: "[msvc] Install Ninja"
        if: matrix.toolchain == 'msvc'
        shell: powershell
        run: choco install ninja -y

      # ========================================
      # TOOLCHAIN SETUP: clang-cl
      # ========================================
      - name: "[clang-cl] Set up MSVC environment"
        if: matrix.toolchain == 'clang-cl'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: "[clang-cl] Install tools"
        if: matrix.toolchain == 'clang-cl'
        shell: powershell
        run: choco install ninja llvm -y

      # ========================================
      # TOOLCHAIN SETUP: MinGW (MSYS2 CLANG64)
      # ========================================
      - name: "[mingw] Set up MSYS2"
        if: matrix.toolchain == 'mingw'
        uses: msys2/setup-msys2@v2
        with:
          msystem: CLANG64
          update: true
          install: >-
            mingw-w64-clang-x86_64-clang
            mingw-w64-clang-x86_64-cmake
            mingw-w64-clang-x86_64-ninja
            mingw-w64-clang-x86_64-lld
            mingw-w64-clang-x86_64-python
            git

      # ========================================
      # CLONE
      # ========================================
      - name: Clone CIRCT source
        shell: bash
        run: |
          git clone --recursive --depth 1 --shallow-submodules --branch ${{ steps.version.outputs.tag }} https://github.com/llvm/circt.git

      # Patch: upstream LLVM bug — when LLVM_BUILD_LLVM_DYLIB=ON, ArmSMEStubs.cpp
      # gets compiled into the monolithic DLL but the per-target export define
      # (mlir_arm_sme_abi_stubs_EXPORTS) is never set, so the macro defaults to
      # __declspec(dllimport) on function definitions, which is illegal.
      # Fix: strip the MLIR_ARMSMEABISTUBS_EXPORTED macro from function definitions.
      - name: Patch ArmSMEStubs.cpp (upstream dllimport bug)
        shell: bash
        run: |
          STUBS_FILE="circt/llvm/mlir/lib/ExecutionEngine/ArmSMEStubs.cpp"
          if [ -f "$STUBS_FILE" ]; then
            echo "Patching $STUBS_FILE to fix dllimport on definitions..."
            sed -i 's/MLIR_ARMSMEABISTUBS_EXPORTED //g' "$STUBS_FILE"
            echo "Patch applied."
          else
            echo "ArmSMEStubs.cpp not found — skipping patch (may not be needed)."
          fi

      # Patch: upstream CIRCT bug — ESIServices.cpp calls ServiceImplRecordOp::create()
      # passing UnitAttr() for the 'isEngine' parameter. Clang (clang-cl and clang) cannot
      # resolve which create() overload to use because UnitAttr() is implicitly convertible
      # to multiple Attribute-derived types. MSVC is permissive and resolves it silently;
      # Clang is strict and emits "call to 'create' is ambiguous".
      # Fix: qualify the argument as mlir::UnitAttr{} so the overload is unambiguous.
      - name: "[clang-cl] Patch ESIServices.cpp (ambiguous UnitAttr create overload)"
        if: matrix.toolchain == 'clang-cl'
        shell: bash
        run: |
          ESI_FILE="circt/lib/Dialect/ESI/ESIServices.cpp"
          if [ -f "$ESI_FILE" ]; then
            echo "Patching $ESI_FILE to resolve ambiguous ServiceImplRecordOp::create call..."
            # Replace UnitAttr() with mlir::UnitAttr{} to make clang's overload
            # resolution unambiguous. The cast forces the argument to the exact
            # mlir::UnitAttr type rather than leaving it as an implicit conversion candidate.
            sed -i 's|/\*isEngine=\*/UnitAttr()|/*isEngine=*/mlir::UnitAttr{}|g' "$ESI_FILE"
            echo "Patch applied."
            grep -n 'isEngine' "$ESI_FILE" || echo "(no isEngine occurrences found after patch)"
          else
            echo "ESIServices.cpp not found — skipping patch."
          fi

      # Patch: upstream LLVM/MLIR bug (mingw only) — mlir-irdl-to-cpp links only against
      # MLIRTargetIRDLToCpp via mlir_target_link_libraries(), but that helper does NOT
      # automatically propagate transitive static deps on MinGW (where LLVM_LINK_LLVM_DYLIB
      # is OFF). The linker therefore cannot find symbols from MLIRIR, MLIRSupport, etc.
      # Fix: append an explicit target_link_libraries with all transitive deps that
      # MLIRTargetIRDLToCpp requires when linked statically.
      - name: "[mingw] Patch mlir-irdl-to-cpp CMakeLists (missing transitive static deps)"
        if: matrix.toolchain == 'mingw'
        shell: bash
        run: |
          CMAKE_FILE="circt/llvm/mlir/tools/mlir-irdl-to-cpp/CMakeLists.txt"
          if [ -f "$CMAKE_FILE" ]; then
            echo "Patching $CMAKE_FILE to add missing transitive link dependencies..."
            printf '\n# Workflow patch: explicit transitive deps for MinGW static link builds.\n# mlir_target_link_libraries does not propagate transitive static archives\n# on MinGW when LLVM_LINK_LLVM_DYLIB=OFF. List them explicitly here.\ntarget_link_libraries(mlir-irdl-to-cpp\n  PRIVATE\n    MLIRIR\n    MLIRParser\n    MLIRSupport\n    MLIRBytecodeReader\n    MLIRIRDLToLLVMIRTranslation\n    MLIRTranslateLib\n    MLIRFunctionInterfaces\n    MLIRTargetIRDLToCpp\n)\n' >> "$CMAKE_FILE"
            echo "Patch applied."
          else
            echo "mlir-irdl-to-cpp/CMakeLists.txt not found — skipping patch."
          fi

      # Patch: upstream LLVM/MLIR bug (mingw only) — mlir-pdll fails to link because
      # add_tablegen() does not pull in all transitive deps of MLIRPDLLODS and
      # MLIRPDLLCodeGen under MinGW's static link model.
      # Fix: append explicit target_link_libraries covering the missing symbols.
      - name: "[mingw] Patch mlir-pdll CMakeLists (missing transitive static deps)"
        if: matrix.toolchain == 'mingw'
        shell: bash
        run: |
          PDLL_FILE="circt/llvm/mlir/tools/mlir-pdll/CMakeLists.txt"
          if [ -f "$PDLL_FILE" ]; then
            echo "Patching $PDLL_FILE to add missing transitive link dependencies..."
            printf '\n# Workflow patch: explicit transitive deps for MinGW static link builds.\ntarget_link_libraries(mlir-pdll\n  PRIVATE\n    MLIRIR\n    MLIRSupport\n    MLIRParser\n    MLIRPDLLCodeGen\n    MLIRPDLLAST\n    MLIRPDLLODS\n    MLIRPDLLParser\n    MLIRSideEffectInterfaces\n)\n' >> "$PDLL_FILE"
            echo "Patch applied."
          else
            echo "mlir-pdll/CMakeLists.txt not found — skipping patch."
          fi

      # ========================================
      # CONFIGURE: per-toolchain CMake flags
      # All three attempt LLVM_BUILD_LLVM_DYLIB=ON to test shared DLL feasibility
      # ========================================
      - name: "[msvc] Configure CIRCT (shared DLL attempt, cl.exe)"
        if: matrix.toolchain == 'msvc'
        run: |
          cmake -G Ninja -S circt/llvm/llvm -B build ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_INSTALL_PREFIX=${{ github.workspace }}/install ^
            -DPython3_EXECUTABLE="${{ env.pythonLocation }}/python.exe" ^
            -DLLVM_ENABLE_PROJECTS="mlir" ^
            -DLLVM_EXTERNAL_PROJECTS=circt ^
            -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=${{ github.workspace }}/circt ^
            -DLLVM_BUILD_LLVM_DYLIB=ON ^
            -DLLVM_LINK_LLVM_DYLIB=ON ^
            -DLLVM_TARGETS_TO_BUILD="host" ^
            -DLLVM_INCLUDE_TESTS=OFF ^
            -DLLVM_INCLUDE_EXAMPLES=OFF ^
            -DLLVM_INCLUDE_BENCHMARKS=OFF ^
            -DLLVM_INCLUDE_DOCS=OFF ^
            -DLLVM_ENABLE_ASSERTIONS=OFF ^
            -DLLVM_ENABLE_ZLIB=OFF ^
            -DLLVM_ENABLE_ZSTD=OFF

      - name: "[clang-cl] Configure CIRCT (shared DLL attempt, clang-cl + lld)"
        if: matrix.toolchain == 'clang-cl'
        run: |
          cmake -G Ninja -S circt/llvm/llvm -B build ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_INSTALL_PREFIX=${{ github.workspace }}/install ^
            -DCMAKE_C_COMPILER=clang-cl ^
            -DCMAKE_CXX_COMPILER=clang-cl ^
            -DLLVM_USE_LINKER=lld ^
            -DPython3_EXECUTABLE="${{ env.pythonLocation }}/python.exe" ^
            -DLLVM_ENABLE_PROJECTS="mlir" ^
            -DLLVM_EXTERNAL_PROJECTS=circt ^
            -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=${{ github.workspace }}/circt ^
            -DLLVM_BUILD_LLVM_DYLIB=ON ^
            -DLLVM_LINK_LLVM_DYLIB=ON ^
            -DLLVM_TARGETS_TO_BUILD="host" ^
            -DLLVM_INCLUDE_TESTS=OFF ^
            -DLLVM_INCLUDE_EXAMPLES=OFF ^
            -DLLVM_INCLUDE_BENCHMARKS=OFF ^
            -DLLVM_INCLUDE_DOCS=OFF ^
            -DLLVM_ENABLE_ASSERTIONS=OFF ^
            -DLLVM_ENABLE_ZLIB=OFF ^
            -DLLVM_ENABLE_ZSTD=OFF

      # MinGW uses MSYS2's own Python, does not need pythonLocation from setup-python.
      #
      # Note on LLVM_LINK_LLVM_DYLIB: intentionally NOT set for MinGW.
      # LLVM_BUILD_LLVM_DYLIB=ON is enough to build libLLVM.dll (the experiment goal).
      # LLVM_LINK_LLVM_DYLIB=ON would additionally force every tool to prefer the shared
      # dylib over static libs — this triggers the upstream mlir-irdl-to-cpp CMakeLists
      # bug (missing transitive deps) even after our patch, because the static-lib
      # fallback is needed to cleanly resolve all symbols on MinGW.
      # With LLVM_BUILD_LLVM_DYLIB=ON only: DLL is built and inspectable, tools still
      # link cleanly against static component libs.
      - name: "[mingw] Configure CIRCT (shared DLL attempt, MSYS2 CLANG64)"
        if: matrix.toolchain == 'mingw'
        run: |
          cmake -G Ninja -S circt/llvm/llvm -B build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=${{ github.workspace }}/install \
            -DLLVM_ENABLE_PROJECTS="mlir" \
            -DLLVM_EXTERNAL_PROJECTS=circt \
            -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=${{ github.workspace }}/circt \
            -DLLVM_BUILD_LLVM_DYLIB=ON \
            -DMLIR_BUILD_MLIR_C_DYLIB=ON \
            -DLLVM_TARGETS_TO_BUILD="host" \
            -DLLVM_INCLUDE_TESTS=OFF \
            -DLLVM_INCLUDE_EXAMPLES=OFF \
            -DLLVM_INCLUDE_BENCHMARKS=OFF \
            -DLLVM_INCLUDE_DOCS=OFF \
            -DLLVM_ENABLE_ASSERTIONS=OFF \
            -DLLVM_ENABLE_ZLIB=OFF \
            -DLLVM_ENABLE_ZSTD=OFF

      # continue-on-error: allows the validation steps to still run and report
      # which DLLs/tools were produced, even if a minority of tools fail to link
      # (particularly relevant for the mingw toolchain during experimentation).
      - name: Build CIRCT
        continue-on-error: ${{ matrix.toolchain == 'mingw' }}
        run: cmake --build build --config Release --parallel ${{ matrix.parallel_jobs }}

      - name: Install CIRCT
        run: cmake --install build --config Release

      # ========================================
      # VALIDATION: check what was produced
      # ========================================
      - name: List installed binaries
        shell: bash
        run: |
          echo "=== bin/ ==="
          ls -la install/bin/ 2>/dev/null | head -30 || echo "No bin directory"
          echo ""
          echo "=== lib/ (DLLs and shared libs) ==="
          find install/lib/ -name "*.dll" -o -name "*.so" -o -name "*.dylib" 2>/dev/null | head -20 || echo "No shared libs found"
          echo ""
          echo "=== lib/ (static libs) ==="
          find install/lib/ -name "*.lib" -o -name "*.a" 2>/dev/null | wc -l || echo "0"
          echo " static library files"
          echo ""
          echo "=== Disk usage ==="
          du -sh install/ 2>/dev/null || echo "No install dir"

      - name: Test firtool runs
        shell: bash
        continue-on-error: true
        run: |
          echo "Testing firtool --version..."
          install/bin/firtool --version 2>&1 || echo "firtool not found or failed"
          echo ""
          echo "Testing circt-opt --version..."
          install/bin/circt-opt --version 2>&1 || echo "circt-opt not found or failed"

      - name: Package results
        shell: bash
        run: |
          tar -czf "circt-${{ steps.version.outputs.version }}-windows-x64-${{ matrix.toolchain }}.tar.gz" -C install .

      - name: Upload release assets
        if: github.ref_type == 'tag'
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: circt-${{ steps.version.outputs.version }}-windows-x64-${{ matrix.toolchain }}.tar.gz
          tag_name: ${{ github.ref_name }}
          name: "[Experiment] CIRCT ${{ steps.version.outputs.version }} Windows Toolchain Test"
          draft: false
          prerelease: true

      - name: Upload artifact (manual dispatch)
        if: github.ref_type != 'tag'
        uses: actions/upload-artifact@v4
        with:
          name: circt-${{ steps.version.outputs.version }}-windows-${{ matrix.toolchain }}
          path: circt-${{ steps.version.outputs.version }}-windows-x64-${{ matrix.toolchain }}.tar.gz
          retention-days: 7
